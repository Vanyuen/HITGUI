# 热温冷分析表详细设计文档

## 1. 热温冷分析原理

### 1.1 概念定义

**热温冷分析**是彩票数据分析中的一种重要统计方法，通过分析号码在近期出现的频率来判断号码的"温度"状态：

- **热号 (Hot)**：在统计期内出现频率明显高于平均值的号码
- **温号 (Warm)**：在统计期内出现频率接近平均值的号码
- **冷号 (Cold)**：在统计期内出现频率明显低于平均值的号码

### 1.2 分析价值

1. **预测参考**：热温冷状态可作为号码选择的重要参考依据
2. **风险控制**：避免过度集中选择同一温度类型的号码
3. **趋势识别**：通过温度变化识别号码出现的周期性规律
4. **组合优化**：在组合生成时平衡不同温度号码的比例

## 2. 数据表结构设计

### 2.1 核心分析表 (dlt_htc_analysis)

```javascript
{
  _id: ObjectId,                    // MongoDB主键

  // === 基础信息 ===
  analysis_date: Date,              // 分析日期
  target_issue: String,             // 目标期号(用于预测的期号)
  analysis_period: Number,          // 分析期数(例如30期)
  issue_range: {                    // 分析的期号范围
    start_issue: String,            // 起始期号
    end_issue: String,              // 结束期号
    total_issues: Number            // 实际分析期数
  },

  // === 红球分析数据 ===
  red_numbers: {
    // 每个号码的详细分析
    "01": {
      hit_count: Number,            // 命中次数
      hit_frequency: Number,        // 命中频率 (0.0-1.0)
      expected_frequency: Number,   // 期望频率 (5/35=0.1429)
      deviation: Number,            // 偏差值 (实际频率-期望频率)
      temperature: String,          // 温度类型: "hot"|"warm"|"cold"
      trend: String,               // 趋势: "rising"|"stable"|"falling"
      last_appear_issue: String,   // 最后出现期号
      absence_count: Number,       // 连续未出现次数

      // 权重分析
      weights: {
        recency_weight: Number,    // 近期权重(越近期权重越高)
        frequency_weight: Number,  // 频率权重
        trend_weight: Number,      // 趋势权重
        pattern_weight: Number,    // 模式权重
        combined_weight: Number    // 综合权重
      },

      // 分期统计
      period_stats: {
        recent_10: Number,         // 最近10期出现次数
        recent_15: Number,         // 最近15期出现次数
        recent_20: Number,         // 最近20期出现次数
        first_half: Number,        // 前半期出现次数
        second_half: Number        // 后半期出现次数
      }
    },
    // ... 其他号码01-35
  },

  // === 蓝球分析数据 ===
  blue_numbers: {
    // 结构同红球，号码范围01-12
    "01": { /* 同红球结构 */ },
    // ... 其他号码01-12
  },

  // === 温度分布统计 ===
  temperature_distribution: {
    red_balls: {
      hot_count: Number,           // 热号数量
      warm_count: Number,          // 温号数量
      cold_count: Number,          // 冷号数量
      hot_numbers: [String],       // 热号列表
      warm_numbers: [String],      // 温号列表
      cold_numbers: [String]       // 冷号列表
    },
    blue_balls: {
      hot_count: Number,
      warm_count: Number,
      cold_count: Number,
      hot_numbers: [String],
      warm_numbers: [String],
      cold_numbers: [String]
    }
  },

  // === 分析参数 ===
  analysis_parameters: {
    hot_threshold: Number,         // 热号阈值(默认0.7)
    cold_threshold: Number,        // 冷号阈值(默认0.3)
    recency_factor: Number,        // 近期因子(默认2.0)
    trend_periods: Number,         // 趋势分析期数(默认10)
    weight_decay: Number           // 权重衰减因子(默认0.95)
  },

  // === 创建和更新时间 ===
  created_at: Date,
  updated_at: Date,

  // === 索引字段 ===
  cache_key: String                // 缓存键值，便于快速查询
}
```

### 2.2 组合热温冷映射表 (dlt_combination_htc_mapping)

```javascript
{
  _id: ObjectId,

  // === 基础信息 ===
  analysis_date: Date,
  target_issue: String,
  analysis_period: Number,

  // === 组合信息 ===
  combination_id: Number,          // 红球组合ID (1-324632)
  combination_numbers: [Number],   // 组合号码 [5,12,18,25,33]

  // === 热温冷分析结果 ===
  htc_analysis: {
    // 组合中每个号码的温度
    number_temperatures: [String], // ["hot","warm","hot","cold","warm"]

    // 温度分布
    temperature_count: {
      hot: Number,                 // 热号个数
      warm: Number,                // 温号个数
      cold: Number                 // 冷号个数
    },

    // 温度比例
    temperature_ratio: String,     // "1:2:2" (热:温:冷)

    // 综合温度评分
    overall_temperature: String,   // "balanced"|"hot_bias"|"cold_bias"
    temperature_score: Number,     // 温度评分(0-100)

    // 平衡度分析
    balance_analysis: {
      is_balanced: Boolean,        // 是否平衡
      balance_score: Number,       // 平衡分数
      balance_type: String,        // "excellent"|"good"|"fair"|"poor"
      recommendation: String       // 推荐程度
    }
  },

  // === 历史表现 ===
  historical_performance: {
    similar_combinations: [        // 相似温度组合的历史表现
      {
        issue: String,
        hit_count: Number,         // 命中个数
        similarity: Number         // 相似度
      }
    ],
    average_hit_rate: Number,      // 平均命中率
    expected_hit_count: Number     // 预期命中个数
  },

  created_at: Date,
  updated_at: Date
}
```

### 2.3 热温冷趋势分析表 (dlt_htc_trends)

```javascript
{
  _id: ObjectId,

  // === 基础信息 ===
  number: String,                  // 号码 "01"-"35"
  ball_type: String,               // "red"|"blue"
  analysis_date: Date,

  // === 趋势数据 ===
  trend_data: [
    {
      period_end: String,          // 期号
      analysis_periods: Number,    // 分析期数
      hit_count: Number,           // 命中次数
      hit_frequency: Number,       // 命中频率
      temperature: String,         // 温度类型
      trend_direction: String,     // 趋势方向: "up"|"down"|"stable"
      trend_strength: Number,      // 趋势强度(0-1)
      temperature_change: String   // 温度变化: "heating"|"cooling"|"stable"
    }
  ],

  // === 周期性分析 ===
  cycle_analysis: {
    has_cycle: Boolean,            // 是否有周期性
    cycle_length: Number,          // 周期长度
    cycle_phase: String,           // 当前周期阶段
    cycle_confidence: Number       // 周期置信度
  },

  created_at: Date,
  updated_at: Date
}
```

## 3. 热温冷计算算法

### 3.1 基础计算算法

```javascript
class HTCAnalyzer {
  constructor(config = {}) {
    this.config = {
      analysisRangePeriods: config.analysisRangePeriods || 30,  // 分析期数
      hotThreshold: config.hotThreshold || 0.7,        // 热号阈值
      coldThreshold: config.coldThreshold || 0.3,      // 冷号阈值
      recencyFactor: config.recencyFactor || 2.0,      // 近期因子
      trendPeriods: config.trendPeriods || 10,         // 趋势分析期数
      weightDecay: config.weightDecay || 0.95          // 权重衰减
    };
  }

  /**
   * 分析单个号码的热温冷状态
   */
  analyzeNumber(number, historicalData) {
    const analysis = {
      number: number,
      hit_count: 0,
      hit_frequency: 0,
      expected_frequency: 5/35, // 红球期望频率
      deviation: 0,
      temperature: 'warm',
      trend: 'stable',
      last_appear_issue: null,
      absence_count: 0,
      weights: {},
      period_stats: {}
    };

    // 1. 计算基础统计
    analysis.hit_count = this.calculateHitCount(number, historicalData);
    analysis.hit_frequency = analysis.hit_count / historicalData.length;
    analysis.deviation = analysis.hit_frequency - analysis.expected_frequency;

    // 2. 确定温度类型
    analysis.temperature = this.determineTemperature(analysis.hit_frequency);

    // 3. 计算权重
    analysis.weights = this.calculateWeights(number, historicalData);

    // 4. 分析趋势
    analysis.trend = this.analyzeTrend(number, historicalData);

    // 5. 计算分期统计
    analysis.period_stats = this.calculatePeriodStats(number, historicalData);

    // 6. 计算缺失信息
    const absenceInfo = this.calculateAbsenceInfo(number, historicalData);
    analysis.last_appear_issue = absenceInfo.lastIssue;
    analysis.absence_count = absenceInfo.absenceCount;

    return analysis;
  }

  /**
   * 计算号码命中次数
   */
  calculateHitCount(number, historicalData) {
    return historicalData.reduce((count, record) => {
      return record.FrontNumbers.includes(parseInt(number)) ? count + 1 : count;
    }, 0);
  }

  /**
   * 确定温度类型
   */
  determineTemperature(frequency) {
    const expectedFreq = 5/35; // 红球期望频率
    const relativeFreq = frequency / expectedFreq;

    if (relativeFreq >= this.config.hotThreshold) {
      return 'hot';
    } else if (relativeFreq <= this.config.coldThreshold) {
      return 'cold';
    } else {
      return 'warm';
    }
  }

  /**
   * 计算加权分析
   */
  calculateWeights(number, historicalData) {
    const weights = {
      recency_weight: 0,
      frequency_weight: 0,
      trend_weight: 0,
      pattern_weight: 0,
      combined_weight: 0
    };

    // 1. 近期权重计算
    let recentWeight = 0;
    let weightSum = 0;

    historicalData.forEach((record, index) => {
      const periodWeight = Math.pow(this.config.weightDecay, index);
      weightSum += periodWeight;

      if (record.FrontNumbers.includes(parseInt(number))) {
        recentWeight += periodWeight * this.config.recencyFactor;
      }
    });

    weights.recency_weight = recentWeight / weightSum;

    // 2. 频率权重
    const hitCount = this.calculateHitCount(number, historicalData);
    weights.frequency_weight = hitCount / historicalData.length;

    // 3. 趋势权重
    weights.trend_weight = this.calculateTrendWeight(number, historicalData);

    // 4. 模式权重
    weights.pattern_weight = this.calculatePatternWeight(number, historicalData);

    // 5. 综合权重
    weights.combined_weight = (
      weights.recency_weight * 0.4 +
      weights.frequency_weight * 0.3 +
      weights.trend_weight * 0.2 +
      weights.pattern_weight * 0.1
    );

    return weights;
  }

  /**
   * 分析号码趋势
   */
  analyzeTrend(number, historicalData) {
    const trendPeriods = Math.min(this.config.trendPeriods, historicalData.length);
    const recentData = historicalData.slice(0, trendPeriods);
    const earlierData = historicalData.slice(trendPeriods, trendPeriods * 2);

    if (earlierData.length === 0) return 'stable';

    const recentFreq = this.calculateHitCount(number, recentData) / recentData.length;
    const earlierFreq = this.calculateHitCount(number, earlierData) / earlierData.length;

    const trendValue = recentFreq - earlierFreq;
    const threshold = 0.05; // 5%的变化阈值

    if (trendValue > threshold) {
      return 'rising';
    } else if (trendValue < -threshold) {
      return 'falling';
    } else {
      return 'stable';
    }
  }

  /**
   * 计算分期统计
   */
  calculatePeriodStats(number, historicalData) {
    const stats = {};
    const periods = [10, 15, 20];

    periods.forEach(period => {
      const data = historicalData.slice(0, Math.min(period, historicalData.length));
      stats[`recent_${period}`] = this.calculateHitCount(number, data);
    });

    // 前后半期统计
    const halfLength = Math.floor(historicalData.length / 2);
    stats.first_half = this.calculateHitCount(number, historicalData.slice(halfLength));
    stats.second_half = this.calculateHitCount(number, historicalData.slice(0, halfLength));

    return stats;
  }

  /**
   * 计算缺失信息
   */
  calculateAbsenceInfo(number, historicalData) {
    let lastIssue = null;
    let absenceCount = 0;

    for (let i = 0; i < historicalData.length; i++) {
      const record = historicalData[i];
      if (record.FrontNumbers.includes(parseInt(number))) {
        lastIssue = record.Issue;
        break;
      }
      absenceCount++;
    }

    return { lastIssue, absenceCount };
  }
}
```

### 3.2 组合热温冷分析算法

```javascript
class CombinationHTCAnalyzer {
  constructor(htcAnalyzer) {
    this.htcAnalyzer = htcAnalyzer;
  }

  /**
   * 分析组合的热温冷状态
   */
  analyzeCombination(combination, historicalData, numberAnalysis) {
    const analysis = {
      combination_numbers: combination,
      number_temperatures: [],
      temperature_count: { hot: 0, warm: 0, cold: 0 },
      temperature_ratio: '',
      overall_temperature: '',
      temperature_score: 0,
      balance_analysis: {}
    };

    // 1. 分析每个号码的温度
    combination.forEach(number => {
      const numStr = number.toString().padStart(2, '0');
      const temp = numberAnalysis[numStr]?.temperature || 'warm';
      analysis.number_temperatures.push(temp);
      analysis.temperature_count[temp]++;
    });

    // 2. 计算温度比例
    analysis.temperature_ratio = `${analysis.temperature_count.hot}:${analysis.temperature_count.warm}:${analysis.temperature_count.cold}`;

    // 3. 确定整体温度倾向
    analysis.overall_temperature = this.determineOverallTemperature(analysis.temperature_count);

    // 4. 计算温度评分
    analysis.temperature_score = this.calculateTemperatureScore(analysis.temperature_count, numberAnalysis, combination);

    // 5. 平衡度分析
    analysis.balance_analysis = this.analyzeBalance(analysis.temperature_count);

    return analysis;
  }

  /**
   * 确定整体温度倾向
   */
  determineOverallTemperature(tempCount) {
    const total = tempCount.hot + tempCount.warm + tempCount.cold;
    const hotRatio = tempCount.hot / total;
    const coldRatio = tempCount.cold / total;

    if (hotRatio >= 0.6) {
      return 'hot_bias';
    } else if (coldRatio >= 0.6) {
      return 'cold_bias';
    } else {
      return 'balanced';
    }
  }

  /**
   * 计算温度评分
   */
  calculateTemperatureScore(tempCount, numberAnalysis, combination) {
    let totalScore = 0;

    combination.forEach(number => {
      const numStr = number.toString().padStart(2, '0');
      const analysis = numberAnalysis[numStr];

      if (analysis) {
        // 基础分数
        let numberScore = 50;

        // 根据温度类型调整
        switch (analysis.temperature) {
          case 'hot':
            numberScore += 15;
            break;
          case 'warm':
            numberScore += 25; // 温号得分最高
            break;
          case 'cold':
            numberScore += 10;
            break;
        }

        // 根据趋势调整
        switch (analysis.trend) {
          case 'rising':
            numberScore += 10;
            break;
          case 'stable':
            numberScore += 5;
            break;
          case 'falling':
            numberScore -= 5;
            break;
        }

        // 根据权重调整
        numberScore += analysis.weights.combined_weight * 20;

        totalScore += Math.min(100, Math.max(0, numberScore));
      }
    });

    // 平衡度奖励
    const balanceBonus = this.calculateBalanceBonus(tempCount);
    totalScore = (totalScore / combination.length) + balanceBonus;

    return Math.min(100, Math.max(0, totalScore));
  }

  /**
   * 计算平衡度奖励
   */
  calculateBalanceBonus(tempCount) {
    const total = tempCount.hot + tempCount.warm + tempCount.cold;

    // 理想分布: 1热 2温 2冷 或 2热 2温 1冷
    const idealDistributions = [
      [1, 2, 2], [2, 2, 1], [1, 3, 1], [2, 1, 2]
    ];

    let maxBonus = 0;

    idealDistributions.forEach(ideal => {
      const diff = Math.abs(tempCount.hot - ideal[0]) +
                  Math.abs(tempCount.warm - ideal[1]) +
                  Math.abs(tempCount.cold - ideal[2]);

      const bonus = Math.max(0, 10 - diff * 2);
      maxBonus = Math.max(maxBonus, bonus);
    });

    return maxBonus;
  }

  /**
   * 平衡度分析
   */
  analyzeBalance(tempCount) {
    const total = tempCount.hot + tempCount.warm + tempCount.cold;
    const balance = {
      is_balanced: false,
      balance_score: 0,
      balance_type: 'poor',
      recommendation: 'low'
    };

    // 计算标准差
    const mean = total / 3;
    const variance = ((tempCount.hot - mean) ** 2 +
                     (tempCount.warm - mean) ** 2 +
                     (tempCount.cold - mean) ** 2) / 3;
    const stdDev = Math.sqrt(variance);

    // 根据标准差评估平衡度
    if (stdDev <= 0.5) {
      balance.balance_type = 'excellent';
      balance.balance_score = 90;
      balance.recommendation = 'high';
      balance.is_balanced = true;
    } else if (stdDev <= 1.0) {
      balance.balance_type = 'good';
      balance.balance_score = 75;
      balance.recommendation = 'medium';
      balance.is_balanced = true;
    } else if (stdDev <= 1.5) {
      balance.balance_type = 'fair';
      balance.balance_score = 60;
      balance.recommendation = 'medium';
    } else {
      balance.balance_type = 'poor';
      balance.balance_score = 40;
      balance.recommendation = 'low';
    }

    return balance;
  }
}
```

## 4. 动态更新机制

### 4.1 自动更新触发器

```javascript
class HTCAutoUpdater {
  constructor(config) {
    this.config = config;
    this.updateSchedule = null;
    this.isUpdating = false;
  }

  /**
   * 启动自动更新
   */
  startAutoUpdate() {
    // 每日凌晨2点更新
    this.updateSchedule = schedule.scheduleJob('0 2 * * *', async () => {
      await this.performUpdate();
    });

    // 新开奖后立即更新
    this.watchForNewDraws();
  }

  /**
   * 监听新开奖
   */
  watchForNewDraws() {
    // 使用MongoDB Change Streams监听新数据
    const changeStream = db.collection('dlt_records').watch();

    changeStream.on('change', async (change) => {
      if (change.operationType === 'insert') {
        console.log('检测到新开奖数据:', change.fullDocument.Issue);
        await this.performUpdate();
      }
    });
  }

  /**
   * 执行更新
   */
  async performUpdate() {
    if (this.isUpdating) {
      console.log('更新正在进行中，跳过此次更新');
      return;
    }

    this.isUpdating = true;

    try {
      console.log('开始热温冷分析更新...');

      // 1. 获取最新数据
      const latestData = await this.getLatestData();

      // 2. 执行分析
      const analyzer = new HTCAnalyzer();
      const analysisResult = await analyzer.performFullAnalysis(latestData);

      // 3. 更新数据库
      await this.updateDatabase(analysisResult);

      // 4. 清理过期数据
      await this.cleanupExpiredData();

      console.log('热温冷分析更新完成');

    } catch (error) {
      console.error('热温冷分析更新失败:', error);
    } finally {
      this.isUpdating = false;
    }
  }

  /**
   * 获取最新数据
   */
  async getLatestData() {
    const latestIssue = await DLTRecord.findOne().sort({ Issue: -1 });
    if (!latestIssue) throw new Error('没有找到开奖数据');

    const analysisData = await DLTRecord
      .find({ Issue: { $lte: latestIssue.Issue } })
      .sort({ Issue: -1 })
      .limit(this.config.analysisRangePeriods);

    return {
      latestIssue: latestIssue.Issue,
      historicalData: analysisData
    };
  }

  /**
   * 更新数据库
   */
  async updateDatabase(analysisResult) {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // 1. 更新主分析表
      await HTCAnalysis.findOneAndUpdate(
        {
          target_issue: analysisResult.targetIssue,
          analysis_period: analysisResult.analysisPeriod
        },
        analysisResult,
        {
          upsert: true,
          session: session,
          new: true
        }
      );

      // 2. 更新组合映射表
      await this.updateCombinationMappings(analysisResult, session);

      // 3. 更新趋势分析表
      await this.updateTrendAnalysis(analysisResult, session);

      await session.commitTransaction();

    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  }

  /**
   * 清理过期数据
   */
  async cleanupExpiredData() {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 90); // 保留90天数据

    await Promise.all([
      HTCAnalysis.deleteMany({ analysis_date: { $lt: cutoffDate } }),
      CombinationHTCMapping.deleteMany({ analysis_date: { $lt: cutoffDate } }),
      HTCTrends.deleteMany({ analysis_date: { $lt: cutoffDate } })
    ]);

    console.log('清理过期热温冷数据完成');
  }
}
```

### 4.2 增量更新优化

```javascript
class HTCIncrementalUpdater {
  constructor() {
    this.lastUpdateIssue = null;
    this.cache = new Map();
  }

  /**
   * 增量更新检查
   */
  async checkForUpdates() {
    const lastAnalysis = await HTCAnalysis.findOne().sort({ analysis_date: -1 });
    const latestRecord = await DLTRecord.findOne().sort({ Issue: -1 });

    if (!lastAnalysis || !latestRecord) {
      return { needsFullUpdate: true };
    }

    const lastAnalyzedIssue = lastAnalysis.issue_range.end_issue;
    const latestIssue = latestRecord.Issue;

    if (latestIssue > lastAnalyzedIssue) {
      return {
        needsUpdate: true,
        updateType: 'incremental',
        fromIssue: lastAnalyzedIssue,
        toIssue: latestIssue
      };
    }

    return { needsUpdate: false };
  }

  /**
   * 执行增量更新
   */
  async performIncrementalUpdate(updateInfo) {
    console.log(`执行增量更新: ${updateInfo.fromIssue} -> ${updateInfo.toIssue}`);

    // 1. 获取新数据
    const newRecords = await DLTRecord.find({
      Issue: {
        $gt: updateInfo.fromIssue,
        $lte: updateInfo.toIssue
      }
    }).sort({ Issue: -1 });

    // 2. 获取基础分析数据
    const baseAnalysis = await HTCAnalysis.findOne().sort({ analysis_date: -1 });

    // 3. 增量计算
    const updatedAnalysis = await this.incrementalCalculation(baseAnalysis, newRecords);

    // 4. 保存更新结果
    await this.saveIncrementalResults(updatedAnalysis);

    console.log('增量更新完成');
  }

  /**
   * 增量计算逻辑
   */
  async incrementalCalculation(baseAnalysis, newRecords) {
    const updatedAnalysis = JSON.parse(JSON.stringify(baseAnalysis));

    // 更新基础信息
    updatedAnalysis.analysis_date = new Date();
    updatedAnalysis.issue_range.end_issue = newRecords[0].Issue;
    updatedAnalysis.issue_range.total_issues += newRecords.length;

    // 增量更新每个号码的统计
    for (let number = 1; number <= 35; number++) {
      const numStr = number.toString().padStart(2, '0');
      const numberData = updatedAnalysis.red_numbers[numStr];

      if (numberData) {
        // 更新命中次数
        const newHits = newRecords.reduce((count, record) => {
          return record.FrontNumbers.includes(number) ? count + 1 : count;
        }, 0);

        numberData.hit_count += newHits;
        numberData.hit_frequency = numberData.hit_count / updatedAnalysis.issue_range.total_issues;
        numberData.deviation = numberData.hit_frequency - numberData.expected_frequency;

        // 重新计算温度
        numberData.temperature = this.determineTemperature(numberData.hit_frequency);

        // 更新最后出现信息
        const lastAppear = newRecords.find(record => record.FrontNumbers.includes(number));
        if (lastAppear) {
          numberData.last_appear_issue = lastAppear.Issue;
          numberData.absence_count = 0;
        } else {
          numberData.absence_count += newRecords.length;
        }
      }
    }

    // 重新计算温度分布
    updatedAnalysis.temperature_distribution = this.recalculateTemperatureDistribution(updatedAnalysis.red_numbers);

    return updatedAnalysis;
  }
}
```

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u8be6\u7ec6\u8bf4\u660e\u70ed\u6e29\u51b7\u5206\u6790\u8868\u7684\u8bbe\u8ba1\u539f\u7406", "status": "completed", "activeForm": "\u8be6\u7ec6\u8bf4\u660e\u70ed\u6e29\u51b7\u5206\u6790\u8868\u7684\u8bbe\u8ba1\u539f\u7406"}, {"content": "\u8bbe\u8ba1\u70ed\u6e29\u51b7\u5206\u6790\u8868\u7684\u6570\u636e\u7ed3\u6784", "status": "completed", "activeForm": "\u8bbe\u8ba1\u70ed\u6e29\u51b7\u5206\u6790\u8868\u7684\u6570\u636e\u7ed3\u6784"}, {"content": "\u8bf4\u660e\u70ed\u6e29\u51b7\u8ba1\u7b97\u7b97\u6cd5", "status": "completed", "activeForm": "\u8bf4\u660e\u70ed\u6e29\u51b7\u8ba1\u7b97\u7b97\u6cd5"}, {"content": "\u63d0\u4f9b\u70ed\u6e29\u51b7\u5206\u6790\u7684\u5b9e\u73b0\u4ee3\u7801", "status": "completed", "activeForm": "\u63d0\u4f9b\u70ed\u6e29\u51b7\u5206\u6790\u7684\u5b9e\u73b0\u4ee3\u7801"}, {"content": "\u8bf4\u660e\u52a8\u6001\u66f4\u65b0\u673a\u5236", "status": "completed", "activeForm": "\u8bf4\u660e\u52a8\u6001\u66f4\u65b0\u673a\u5236"}]