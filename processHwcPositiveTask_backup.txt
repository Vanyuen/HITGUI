async function processHwcPositiveTask(taskId) {
    try {
        log(`ğŸ”„ å¼€å§‹å¤„ç†ä»»åŠ¡: ${taskId}`);

        // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºprocessing
        await PredictionTask.updateOne(
            { task_id: taskId },
            {
                status: 'processing',
                started_at: new Date()
            }
        );

        // è·å–ä»»åŠ¡è¯¦æƒ…
        const task = await PredictionTask.findOne({ task_id: taskId }).lean();
        const { issue_range, positive_selection, exclusion_conditions, output_config } = task;

        // å¤„ç†æ¯ä¸ªæœŸå·å¯¹ï¼ˆç›¸é‚»é…å¯¹ï¼‰
        // æ–¹æ¡ˆAï¼šåŒ…å«æ¨ç®—æœŸ - æ¯æœŸä¸ä¸‹ä¸€æœŸé…å¯¹
        for (let i = 0; i < issue_range.length - 1; i++) {
            const baseIssue = issue_range[i];
            const targetIssue = issue_range[i + 1]; // ä¸ä¸‹ä¸€æœŸé…å¯¹

            try {
                // 1. æ­£é€‰ç­›é€‰
                const positiveResult = await fetch('http://localhost:3003/api/dlt/positive-selection/get-combo-ids', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        positiveSelection: positive_selection,
                        baseIssue,
                        targetIssue
                    })
                });

                const positiveData = await positiveResult.json();
                let comboIds = positiveData.data.comboIds;
                log(`  âœ… æ­£é€‰ç­›é€‰å®Œæˆ: ${comboIds.length}ä¸ªç»„åˆ`);

                // 2. åº”ç”¨æ’é™¤æ¡ä»¶
                if (exclusion_conditions) {
                    const beforeCount = comboIds.length;

                    // 2.4 ç›¸å…‹å¯¹æ’é™¤ï¼ˆä¸‰ä¸ªç‹¬ç«‹ç­–ç•¥ï¼‰
                    if (exclusion_conditions.conflictPairs && exclusion_conditions.conflictPairs.enabled) {
                        const conflictConfig = exclusion_conditions.conflictPairs;

                        // 2.4.1 å…¨å±€æ’é™¤Top
                        if (conflictConfig.globalTop && conflictConfig.globalTop.enabled) {
                            const { period, top } = conflictConfig.globalTop;
                            log(`  ğŸ”¥ åº”ç”¨ç›¸å…‹å…¨å±€Topæ’é™¤: åˆ†æ${period}æœŸ, æ’é™¤å‰${top}å¯¹`);

                            // è·å–åŸºå‡†æœŸIDï¼ˆç›®æ ‡æœŸ-1ï¼‰
                            const basePeriodRecord = await hit_dlts.findOne({ Issue: parseInt(baseIssue) });
                            if (basePeriodRecord) {
                                // è·å–çƒ­å·ä¿æŠ¤åˆ—è¡¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                                let protectedHotNumbers = [];
                                if (conflictConfig.globalTop.hotProtect && conflictConfig.globalTop.hotProtect.enabled) {
                                    const hotTop = conflictConfig.globalTop.hotProtect.top;
                                    log(`  ğŸ”¥ å¯ç”¨çƒ­å·ä¿æŠ¤: ä¿æŠ¤å‰${hotTop}åçƒ­å·`);
                                    protectedHotNumbers = await getTopHotNumbers(basePeriodRecord.ID, period, hotTop);
                                    log(`  ğŸ”¥ çƒ­å·ä¿æŠ¤åˆ—è¡¨: ${protectedHotNumbers.join(', ')}`);
                                }

                                // è·å–å…¨å±€Topç›¸å…‹å¯¹
                                const topConflictPairs = await getGlobalConflictTopPairs(basePeriodRecord.ID, period, top, protectedHotNumbers);
                                log(`  ğŸ”¥ å…¨å±€Topç›¸å…‹å¯¹: ${topConflictPairs.length}å¯¹`);

                                // è¿‡æ»¤ç»„åˆ
                                const beforeGlobalCount = comboIds.length;
                                comboIds = await filterComboIdsByConflictPairs(comboIds, topConflictPairs);
                                const excludedCount = beforeGlobalCount - comboIds.length;
                                log(`  ğŸ”¥ å…¨å±€Topæ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                            } else {
                                log(`  âš ï¸ åŸºå‡†æœŸ${baseIssue}ä¸å­˜åœ¨ï¼Œè·³è¿‡å…¨å±€Topæ’é™¤`);
                            }
                        }

                        // 2.4.2 æ¯ä¸ªå·ç æ’é™¤Top
                        if (conflictConfig.perBallTop && conflictConfig.perBallTop.enabled) {
                            const { period, top } = conflictConfig.perBallTop;
                            log(`  ğŸ”¥ åº”ç”¨ç›¸å…‹æ¯å·Topæ’é™¤: åˆ†æ${period}æœŸ, æ¯å·æ’é™¤å‰${top}ä¸ª`);

                            const basePeriodRecord = await hit_dlts.findOne({ Issue: parseInt(baseIssue) });
                            if (basePeriodRecord) {
                                // è·å–çƒ­å·ä¿æŠ¤åˆ—è¡¨ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                                let protectedHotNumbers = [];
                                if (conflictConfig.perBallTop.hotProtect && conflictConfig.perBallTop.hotProtect.enabled) {
                                    const hotTop = conflictConfig.perBallTop.hotProtect.top;
                                    log(`  ğŸ”¥ å¯ç”¨çƒ­å·ä¿æŠ¤: ä¿æŠ¤å‰${hotTop}åçƒ­å·`);
                                    protectedHotNumbers = await getTopHotNumbers(basePeriodRecord.ID, period, hotTop);
                                    log(`  ğŸ”¥ çƒ­å·ä¿æŠ¤åˆ—è¡¨: ${protectedHotNumbers.join(', ')}`);
                                }

                                // è·å–æ¯å·Topç›¸å…‹å·ç 
                                const perBallConflictPairs = await getPerBallConflictTopPairs(basePeriodRecord.ID, period, top, protectedHotNumbers);
                                log(`  ğŸ”¥ æ¯å·Topç›¸å…‹å¯¹: æ€»è®¡${perBallConflictPairs.length}å¯¹`);

                                // è¿‡æ»¤ç»„åˆ
                                const beforePerBallCount = comboIds.length;
                                comboIds = await filterComboIdsByConflictPairs(comboIds, perBallConflictPairs);
                                const excludedCount = beforePerBallCount - comboIds.length;
                                log(`  ğŸ”¥ æ¯å·Topæ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                            } else {
                                log(`  âš ï¸ åŸºå‡†æœŸ${baseIssue}ä¸å­˜åœ¨ï¼Œè·³è¿‡æ¯å·Topæ’é™¤`);
                            }
                        }

                        // 2.4.3 ç›¸å…‹æ¬¡æ•°é˜ˆå€¼ï¼ˆå‘åå…¼å®¹ï¼‰
                        if (conflictConfig.threshold && conflictConfig.threshold.enabled) {
                            const thresholdValue = conflictConfig.threshold.value;
                            log(`  ğŸ”¥ åº”ç”¨ç›¸å…‹æ¬¡æ•°é˜ˆå€¼æ’é™¤: â‰¥${thresholdValue}æ¬¡`);

                            // TODO: å®ç°é˜ˆå€¼è¿‡æ»¤é€»è¾‘
                            log(`  âš ï¸ ç›¸å…‹æ¬¡æ•°é˜ˆå€¼æ’é™¤åŠŸèƒ½å¾…å®ç°`);
                        }
                    }

                    // 2.5 åŒç°æ¯”æ’é™¤ï¼ˆé˜ˆå€¼è¿‡æ»¤ + å†å²æ’é™¤ï¼‰
                    if (exclusion_conditions.coOccurrence && exclusion_conditions.coOccurrence.enabled) {
                        const coOccurConfig = exclusion_conditions.coOccurrence;

                        // 2.5.1 é˜ˆå€¼è¿‡æ»¤ï¼ˆè¿½çƒ­ç­–ç•¥ï¼‰
                        if (coOccurConfig.threshold && coOccurConfig.threshold.enabled) {
                            const { type, threshold, period } = coOccurConfig.threshold;
                            log(`  ğŸ”— åº”ç”¨åŒç°æ¯”é˜ˆå€¼æ’é™¤: ${type}, é˜ˆå€¼${threshold}%, ç»Ÿè®¡${period}æœŸ`);

                            // TODO: å®ç°é˜ˆå€¼è¿‡æ»¤é€»è¾‘
                            // è¿™é‡Œéœ€è¦æ ¹æ®å†å²periodæœŸçš„åŒç°é¢‘ç‡æ•°æ®è¿›è¡Œè¿‡æ»¤
                            // ç›®å‰å…ˆè®°å½•æ—¥å¿—ï¼Œç­‰å¾…åç»­å®ç°å…·ä½“è¿‡æ»¤å‡½æ•°
                            log(`  âš ï¸ åŒç°æ¯”é˜ˆå€¼è¿‡æ»¤åŠŸèƒ½å¾…å®ç°`);
                        }

                        // 2.5.2 å†å²æ’é™¤ï¼ˆé¿é‡ç­–ç•¥ï¼‰
                        if (coOccurConfig.historical && coOccurConfig.historical.enabled) {
                            const { period, combo2, combo3, combo4 } = coOccurConfig.historical;

                            // åªæœ‰åœ¨è‡³å°‘å‹¾é€‰äº†ä¸€ä¸ªå­é€‰é¡¹æ—¶æ‰æ‰§è¡Œ
                            if (combo2 || combo3 || combo4) {
                                log(`  ğŸ”— åº”ç”¨åŒç°æ¯”å†å²æ’é™¤: å€’æ¨${period}æœŸ`);

                                // è·å–åŸºå‡†æœŸIDï¼ˆç›®æ ‡æœŸ-1ï¼‰
                                const basePeriodRecord = await hit_dlts.findOne({ Issue: parseInt(baseIssue) });
                                if (basePeriodRecord) {
                                    // æå–å†å²åŒå‡ºç»„åˆ
                                    const historicalCombos = await getHistoricalCoOccurrenceCombos(
                                        period,
                                        basePeriodRecord.ID,
                                        { combo2, combo3, combo4 }
                                    );

                                    // è¿‡æ»¤comboIdsï¼Œæ’é™¤åŒ…å«å†å²ç»„åˆçš„
                                    const beforeHistCount = comboIds.length;
                                    comboIds = await filterComboIdsByHistoricalCoOccurrence(
                                        comboIds,
                                        historicalCombos
                                    );
                                    const excludedCount = beforeHistCount - comboIds.length;
                                    log(`  ğŸ”— åŒç°æ¯”å†å²æ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                                } else {
                                    log(`  âš ï¸ åŸºå‡†æœŸ${baseIssue}ä¸å­˜åœ¨ï¼Œè·³è¿‡å†å²æ’é™¤`);
                                }
                            } else {
                                log(`  â„¹ï¸ æœªå‹¾é€‰ä»»ä½•åŒå‡ºç»„åˆå­é€‰é¡¹ï¼ˆ2ç /3ç /4ç ï¼‰ï¼Œè·³è¿‡å†å²åŒå‡ºæ’é™¤`);
                            }
                        }

                        // 2.5.3 æŒ‰çº¢çƒå†å²åŒå‡ºæ’é™¤ï¼ˆé¿å¼€æ¯çƒå†å²é…å¯¹ï¼‰
                        if (coOccurConfig.perBall && coOccurConfig.perBall.enabled) {
                            const { periods, combo2, combo3, combo4 } = coOccurConfig.perBall;

                            log(`  ğŸ”— åº”ç”¨æŒ‰çº¢çƒå†å²åŒå‡ºæ’é™¤: æ¯ä¸ªçº¢çƒæœ€è¿‘${periods}æ¬¡å‡ºç°`);

                            // ç¡®å®šæ’é™¤æ¨¡å¼
                            let mode = 'all';  // é»˜è®¤ï¼šæ’é™¤æ‰€æœ‰åŒå‡ºå·ç ç»„åˆ
                            if (combo2 || combo3 || combo4) {
                                mode = 'selective';  // é€‰æ‹©æ€§æ’é™¤
                                log(`  ğŸ”— æ’é™¤æ¨¡å¼: é€‰æ‹©æ€§ï¼ˆ2ç :${combo2}, 3ç :${combo3}, 4ç :${combo4}ï¼‰`);
                            } else {
                                log(`  ğŸ”— æ’é™¤æ¨¡å¼: å…¨éƒ¨ï¼ˆæœªå‹¾é€‰ä»»ä½•å­é€‰é¡¹ï¼Œæ’é™¤æ‰€æœ‰åŒå‡ºç»„åˆï¼‰`);
                            }

                            try {
                                // æŸ¥è¯¢å½“å‰å€™é€‰ç»„åˆçš„è¯¦ç»†æ•°æ®
                                const combinations = await DLTRedCombination.find({
                                    combination_id: { $in: comboIds }
                                }).lean();

                                // è·å–å¾…æ’é™¤çš„åŒå‡ºç‰¹å¾ï¼ˆæŒ‰çº¢çƒåˆ†æï¼‰
                                const excludeFeatures = await this.getExcludeComboFeaturesPerBallForPositiveMode(
                                    baseIssue,
                                    periods,
                                    { combo2, combo3, combo4 }
                                );

                                if (excludeFeatures.combo_2.size > 0 || excludeFeatures.combo_3.size > 0 || excludeFeatures.combo_4.size > 0) {
                                    log(`  ğŸ”— å¾…æ’é™¤ç‰¹å¾(æŒ‰çº¢çƒ) - 2ç :${excludeFeatures.combo_2.size}ä¸ª, 3ç :${excludeFeatures.combo_3.size}ä¸ª, 4ç :${excludeFeatures.combo_4.size}ä¸ª`);

                                    const beforePerBall = comboIds.length;

                                    // ç‰¹å¾åŒ¹é…è¿‡æ»¤
                                    const filteredCombinations = combinations.filter(combo => {
                                        // åŠ¨æ€è®¡ç®—ç»„åˆç‰¹å¾
                                        let combo_2, combo_3, combo_4;

                                        if (combo.combo_2 && combo.combo_3 && combo.combo_4) {
                                            combo_2 = combo.combo_2;
                                            combo_3 = combo.combo_3;
                                            combo_4 = combo.combo_4;
                                        } else {
                                            const features = this.calculateComboFeatures(combo);
                                            combo_2 = features.combo_2;
                                            combo_3 = features.combo_3;
                                            combo_4 = features.combo_4;
                                        }

                                        // ä¼˜å…ˆæ£€æŸ¥4ç ç‰¹å¾ï¼ˆæ—©æœŸé€€å‡ºä¼˜åŒ–ï¼‰
                                        if (excludeFeatures.combo_4.size > 0) {
                                            for (const feature of combo_4) {
                                                if (excludeFeatures.combo_4.has(feature)) {
                                                    return false;
                                                }
                                            }
                                        }

                                        // æ£€æŸ¥3ç ç‰¹å¾
                                        if (excludeFeatures.combo_3.size > 0) {
                                            for (const feature of combo_3) {
                                                if (excludeFeatures.combo_3.has(feature)) {
                                                    return false;
                                                }
                                            }
                                        }

                                        // æ£€æŸ¥2ç ç‰¹å¾
                                        if (excludeFeatures.combo_2.size > 0) {
                                            for (const feature of combo_2) {
                                                if (excludeFeatures.combo_2.has(feature)) {
                                                    return false;
                                                }
                                            }
                                        }

                                        return true;  // ä¿ç•™è¯¥ç»„åˆ
                                    });

                                    comboIds = filteredCombinations.map(c => c.combination_id);
                                    const excludedCount = beforePerBall - comboIds.length;
                                    log(`  ğŸ”— æŒ‰çº¢çƒå†å²åŒå‡ºæ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                                } else {
                                    log(`  âš ï¸ æœªæ‰¾åˆ°å¾…æ’é™¤çš„æŒ‰çº¢çƒåŒå‡ºç‰¹å¾`);
                                }
                            } catch (perBallError) {
                                log(`  âŒ æŒ‰çº¢çƒå†å²åŒå‡ºæ’é™¤å¤±è´¥: ${perBallError.message}`);
                            }
                        }
                    }

                    // 2.6 è¿å·ç»„æ•°æ’é™¤
                    if (exclusion_conditions.consecutiveGroups && exclusion_conditions.consecutiveGroups.enabled) {
                        const { groups } = exclusion_conditions.consecutiveGroups;

                        if (groups && groups.length > 0) {
                            log(`  ğŸ”¢ åº”ç”¨è¿å·ç»„æ•°æ’é™¤: æ’é™¤ ${groups.join(', ')} ç»„`);

                            const beforeConsecutiveGroups = comboIds.length;

                            // æŸ¥è¯¢å€™é€‰ç»„åˆæ•°æ®
                            const combinations = await DLTRedCombination.find({
                                combination_id: { $in: comboIds }
                            }).lean();

                            // è¿‡æ»¤: æ’é™¤æŒ‡å®šè¿å·ç»„æ•°çš„ç»„åˆ
                            const filteredCombinations = combinations.filter(combo => {
                                // åŠ¨æ€è®¡ç®—è¿å·ç‰¹å¾ (å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰é¢„å­˜)
                                let consecutiveGroups;
                                if (combo.consecutive_groups !== undefined && combo.consecutive_groups !== null) {
                                    consecutiveGroups = combo.consecutive_groups;
                                } else {
                                    const analysis = analyzeConsecutive(combo.balls);
                                    consecutiveGroups = analysis.consecutiveGroups;
                                }

                                // ä¿ç•™: è¿å·ç»„æ•°ä¸åœ¨æ’é™¤åˆ—è¡¨ä¸­
                                return !groups.includes(consecutiveGroups);
                            });

                            // æ›´æ–°ç»„åˆIDåˆ—è¡¨
                            comboIds = filteredCombinations.map(c => c.combination_id);

                            const excludedCount = beforeConsecutiveGroups - comboIds.length;
                            log(`  ğŸ”¢ è¿å·ç»„æ•°æ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                        }
                    }

                    // 2.7 æœ€é•¿è¿å·é•¿åº¦æ’é™¤
                    if (exclusion_conditions.maxConsecutiveLength && exclusion_conditions.maxConsecutiveLength.enabled) {
                        const { lengths } = exclusion_conditions.maxConsecutiveLength;

                        if (lengths && lengths.length > 0) {
                            log(`  ğŸ“ åº”ç”¨æœ€é•¿è¿å·é•¿åº¦æ’é™¤: æ’é™¤ ${lengths.join(', ')}`);

                            const beforeMaxConsecutive = comboIds.length;

                            // æŸ¥è¯¢å€™é€‰ç»„åˆæ•°æ®
                            const combinations = await DLTRedCombination.find({
                                combination_id: { $in: comboIds }
                            }).lean();

                            // è¿‡æ»¤: æ’é™¤æŒ‡å®šæœ€é•¿è¿å·é•¿åº¦çš„ç»„åˆ
                            const filteredCombinations = combinations.filter(combo => {
                                // åŠ¨æ€è®¡ç®—è¿å·ç‰¹å¾ (å¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰é¢„å­˜)
                                let maxConsecutiveLength;
                                if (combo.max_consecutive_length !== undefined && combo.max_consecutive_length !== null) {
                                    maxConsecutiveLength = combo.max_consecutive_length;
                                } else {
                                    const analysis = analyzeConsecutive(combo.balls);
                                    maxConsecutiveLength = analysis.maxConsecutiveLength;
                                }

                                // ä¿ç•™: æœ€é•¿è¿å·é•¿åº¦ä¸åœ¨æ’é™¤åˆ—è¡¨ä¸­
                                return !lengths.includes(maxConsecutiveLength);
                            });

                            // æ›´æ–°ç»„åˆIDåˆ—è¡¨
                            comboIds = filteredCombinations.map(c => c.combination_id);

                            const excludedCount = beforeMaxConsecutive - comboIds.length;
                            log(`  ğŸ“ æœ€é•¿è¿å·é•¿åº¦æ’é™¤å: ${comboIds.length}ä¸ªç»„åˆ (æ’é™¤${excludedCount}ä¸ª)`);
                        }
                    }

                    const afterCount = comboIds.length;
                    const totalExcluded = beforeCount - afterCount;
                    log(`  âœ… æ’é™¤æ¡ä»¶å¤„ç†å®Œæˆ: ä¿ç•™${afterCount}ä¸ªç»„åˆ (å…±æ’é™¤${totalExcluded}ä¸ª)`);
                }

                // 3. ä¿å­˜ç»“æœ
                await PredictionTaskResult.create({
                    task_id: taskId,
                    period: targetIssue,
                    base_period: baseIssue,
                    retained_count: comboIds.length,
                    retained_combo_ids: comboIds,
                    created_at: new Date()
                });

                // æ›´æ–°è¿›åº¦
                await PredictionTask.updateOne(
                    { task_id: taskId },
                    {
                        processed_periods: i + 1,
                        progress: Math.round(((i + 1) / issue_range.length) * 100)
                    }
                );

            } catch (error) {
                log(`âš ï¸  å¤„ç†æœŸå· ${baseIssue}->${targetIssue} å¤±è´¥: ${error.message}`);
            }
        }

        // ä»»åŠ¡å®Œæˆ
        await PredictionTask.updateOne(
            { task_id: taskId },
            {
                status: 'completed',
                completed_at: new Date(),
                progress: 100
            }
        );

        log(`âœ… ä»»åŠ¡å®Œæˆ: ${taskId}`);

    } catch (error) {
        log(`âŒ ä»»åŠ¡å¤„ç†å¤±è´¥: ${taskId}, ${error.message}`);

        await PredictionTask.updateOne(
            { task_id: taskId },
            {
                status: 'failed',
                error_message: error.message,
                completed_at: new Date()
            }
        );
    }
}
