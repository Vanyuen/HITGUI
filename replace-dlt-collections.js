const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const COLLECTIONS_TO_REPLACE = [
    'hit_dlts',
    'hit_dlts',
    'hit_dlts',
    'hit_dlts',
    'hit_dlts',
    'hit_dlts',
    'hit_dlts'
];

const TARGET_COLLECTION = 'hit_dlts';

function findFilesWithCollectionNames(rootDir) {
    // ä½¿ç”¨ PowerShell å¹¶è½¬ä¹‰ç‰¹æ®Šå­—ç¬¦å’Œå¤„ç†ä¸­æ–‡è·¯å¾„
    const command =
        'powershell -Command "' +
        `Get-ChildItem -Path "${rootDir}" -Recurse -File | ` +
        `Where-Object { $_.FullName -match '${COLLECTIONS_TO_REPLACE.join('|')}' } | ` +
        'Select-Object -ExpandProperty FullName"';

    try {
        // ä½¿ç”¨ execSync å¹¶æŒ‡å®š utf8 ç¼–ç 
        const output = execSync(command, {
            encoding: 'utf8',
            maxBuffer: 1024 * 1024 * 50
        });

        // å¤„ç†è¾“å‡ºï¼Œå»é™¤ç©ºè¡Œå’Œä¸å­˜åœ¨çš„è·¯å¾„
        return output.trim()
            .split('\n')
            .map(line => line.trim())
            .filter(line =>
                line !== '' &&
                fs.existsSync(line) &&
                fs.statSync(line).isFile()
            );
    } catch (error) {
        console.error(`Error finding files: ${error.message}`);
        return [];
    }
}

function replaceCollectionsInFiles(files) {
    const replacementLog = [];

    for (const file of files) {
        try {
            // ä½¿ç”¨ utf8 ç¼–ç è¯»å–æ–‡ä»¶
            let content = fs.readFileSync(file, 'utf8');
            let originalContent = content;

            // æ›¿æ¢é›†åˆåç§°ï¼Œç¡®ä¿æ˜¯å®Œæ•´å•è¯
            COLLECTIONS_TO_REPLACE.forEach(collection => {
                const regex = new RegExp(`\\b${collection}\\b`, 'g');
                content = content.replace(regex, TARGET_COLLECTION);
            });

            // åªæœ‰å†…å®¹æœ‰å˜åŒ–æ—¶æ‰å†™å…¥
            if (content !== originalContent) {
                // ä½¿ç”¨ utf8 ç¼–ç å†™å…¥æ–‡ä»¶
                fs.writeFileSync(file, content, 'utf8');

                replacementLog.push({
                    file,
                    collections: COLLECTIONS_TO_REPLACE.filter(c => originalContent.includes(c))
                });
            }
        } catch (error) {
            console.error(`Error processing ${file}:`, error);
        }
    }

    return replacementLog;
}

function generateReport(files, replacementLog) {
    const reportPath = path.join('E:\\HITGUI', 'DLT_COLLECTION_REPLACEMENT_REPORT.md');
    const reportContent = `# å¤§ä¹é€æ•°æ®æºé›†åˆæ›¿æ¢æŠ¥å‘Š

## æ›¿æ¢è¯¦æƒ…

æ€»æ–‡ä»¶æ•°: ${files.length}
æ›¿æ¢çš„é›†åˆ: ${COLLECTIONS_TO_REPLACE.join(', ')}
ç›®æ ‡é›†åˆ: ${TARGET_COLLECTION}

### æ›¿æ¢æ–‡ä»¶åˆ—è¡¨

${replacementLog.map(log => `- \`${log.file}\`
  - æ›¿æ¢é›†åˆ: ${log.collections.join(', ')}`).join('\n\n')}

## æ³¨æ„äº‹é¡¹

1. è¯·ä»”ç»†æ£€æŸ¥æ›¿æ¢æ˜¯å¦ç¬¦åˆé¢„æœŸ
2. å»ºè®®åœ¨æ›¿æ¢åè¿›è¡Œå…¨é¢çš„åŠŸèƒ½æµ‹è¯•
3. å¦‚æœ‰ä»»ä½•å¼‚å¸¸ï¼Œè¯·ç«‹å³å›æ»šå¹¶é‡æ–°å®¡æŸ¥

### æ–‡ä»¶æœç´¢è¯¦æƒ…
- æœç´¢ç›®å½•: E:\\HITGUI
- æœç´¢é›†åˆåç§°:
  ${COLLECTIONS_TO_REPLACE.map(c => `- ${c}`).join('\n  ')}

ğŸ¤– Generated by Claude Code
`;

    fs.writeFileSync(reportPath, reportContent, 'utf8');
    console.log(`\nğŸ“‹ ç”Ÿæˆæ›¿æ¢æŠ¥å‘Š: ${reportPath}`);
}

function main() {
    const rootDir = 'E:\\HITGUI';

    console.log('ğŸ” æœç´¢åŒ…å«ä»¥ä¸‹é›†åˆåç§°çš„æ–‡ä»¶:');
    console.log(COLLECTIONS_TO_REPLACE.join(', '));

    const files = findFilesWithCollectionNames(rootDir);

    console.log(`\nğŸ“„ æ‰¾åˆ° ${files.length} ä¸ªéœ€è¦å¤„ç†çš„æ–‡ä»¶`);

    const replacementLog = replaceCollectionsInFiles(files);

    console.log('\nâœ… æ›¿æ¢æ‘˜è¦:');
    replacementLog.forEach(log => {
        console.log(`ğŸ“ ${log.file}`);
        console.log(`   æ›¿æ¢çš„é›†åˆ: ${log.collections.join(', ')}`);
    });

    generateReport(files, replacementLog);

    return replacementLog;
}

module.exports = main;

if (require.main === module) {
    main();
}